# SpecFlow 本地调试方法

## 问题
我要怎么本地进行调试，npm run dev 好像不太好，因为我自己也会使用这个工具，会把我的东西覆盖掉，不好测试。

---

## 回答

### 核心答案
SpecFlow CLI 在运行时会将文件写入 `process.cwd()`（当前工作目录），所以直接在项目根目录运行 `npm run dev` 确实会覆盖你自己的项目文件。推荐的本地调试方法是：**创建一个独立的测试目录，在测试目录中运行命令**。

---

## 详细分析

### 问题根源

SpecFlow CLI 的工作机制：

1. **入口点**：`bin/specflow.js:2` 调用 `../dist/index.js`
2. **init 命令**：`src/commands/init.ts:13` 使用 `process.cwd()` 作为目标目录
   ```typescript
   const cwd = process.cwd();
   const specflowDir = join(cwd, 'specflow');
   ```
3. **文件写入**：在当前工作目录创建 `specflow/` 目录和 `.cursor/` 或 `.iflow/` 命令目录

当你在项目根目录运行 `npm run dev` 时：
- `process.cwd()` 返回项目根目录
- `specflow init` 会在项目根目录创建 `specflow/` 和 `.iflow/commands/`
- 这会覆盖你已有的配置文件

---

## 推荐的调试方法

### 方法 1：独立测试目录（推荐）

创建一个测试项目目录，在其中运行命令：

```bash
# 1. 在项目外创建测试目录
cd C:\Users\piiio\cusrr\free_workspace
mkdir test-specflow
cd test-specflow

# 2. 运行本地开发的 specflow
node C:\Users\piiio\cusrr\free_workspace\spec-flow\dist\index.js init --ai iflow

# 3. 创建任务
node C:\Users\piiio\cusrr\free_workspace\spec-flow\dist\index.js new "测试任务"

# 4. 编辑 brief.md 并测试命令
```

**优点**：
- 完全隔离，不影响主项目
- 可以自由删除测试目录重新开始
- 模拟真实使用场景

---

### 方法 2：使用 npm link

将本地开发版本链接到全局，然后在任意目录测试：

```bash
# 1. 在项目根目录构建并链接
cd C:\Users\piiio\cusrr\free_workspace\spec-flow
npm run build
npm link

# 2. 在任意测试目录使用
cd C:\Users\piiio\cusrr\free_workspace\test-project
specflow init --ai iflow
specflow new "测试任务"

# 3. 开发后重新构建
npm run build
# 无需重新 link，直接使用即可
```

**优点**：
- 使用方便，像全局安装一样
- 修改代码后只需 `npm run build` 即可生效

**注意事项**：
- `npm link` 会创建符号链接，Windows 需要管理员权限
- 测试完成后可以 `npm unlink -g specflow-cli` 解除链接

---

### 方法 3：使用 tsx 直接运行（开发模式）

不构建，直接运行 TypeScript 源码：

```bash
# 1. 创建测试目录
cd C:\Users\piiio\cusrr\free_workspace
mkdir test-specflow
cd test-specflow

# 2. 使用 tsx 运行本地代码
npx tsx C:\Users\piiio\cusrr\free_workspace\spec-flow\src\index.ts init --ai iflow

# 3. 或者设置环境变量
set SPECFLOW_SRC=C:\Users\piiio\cusrr\free_workspace\spec-flow\src
npx tsx %SPECFLOW_SRC%\index.ts new "测试任务"
```

**优点**：
- 无需构建，修改代码立即生效
- 适合快速迭代开发

---

### 方法 4：添加 --cwd 参数（高级）

修改代码支持指定工作目录：

```typescript
// src/index.ts
program
  .command('init')
  .description('初始化 SpecFlow 项目结构')
  .option('--ai <tool>', 'AI 工具类型', 'cursor')
  .option('-f, --force', '强制覆盖已存在的文件')
  .option('--cwd <path>', '指定工作目录')
  .action((options) => init(options));

// src/commands/init.ts
export async function init(options: InitOptions): Promise<void> {
  const cwd = options.cwd || process.cwd(); // 支持指定工作目录
  // ...
}
```

使用方式：

```bash
# 在项目根目录运行，但指定测试目录
npm run dev init --ai iflow --cwd C:\Users\piiio\cusrr\free_workspace\test-specflow
```

**优点**：
- 可以在项目根目录调试
- 灵活指定目标目录

---

## 完整的调试工作流

### 推荐方案：方法 1 + 方法 2 结合

```bash
# === 第一步：构建和链接 ===
cd C:\Users\piiio\cusrr\free_workspace\spec-flow
npm run build
npm link

# === 第二步：创建测试环境 ===
cd C:\Users\piiio\cusrr\free_workspace
rmdir /s /q test-specflow  # 清理旧测试目录（如果存在）
mkdir test-specflow
cd test-specflow

# === 第三步：测试 init 命令 ===
specflow init --ai iflow
# 检查生成的文件：
# - specflow/AGENTS.md
# - specflow/templates/
# - .iflow/commands/

# === 第四步：测试 new 命令 ===
specflow new "用户登录功能"
# 检查生成的目录：
# - specflow/20260120-用户登录功能/

# === 第五步：编辑 brief.md 并测试斜杠命令 ===
# 编辑 specflow/20260120-用户登录功能/brief.md
# 然后在 iflow 中使用 /flow.1-spec 等命令

# === 第六步：修改代码后重新构建 ===
cd C:\Users\piiio\cusrr\free_workspace\spec-flow
# 修改代码...
npm run build

# === 第七步：重新测试 ===
cd C:\Users\piiio\cusrr\free_workspace\test-specflow
rmdir /s /q specflow .iflow  # 清理旧文件
specflow init --ai iflow
# 重新测试...
```

---

## 调试技巧

### 1. 添加调试日志

在关键位置添加 `console.log`：

```typescript
// src/commands/init.ts
console.log('[DEBUG] cwd:', cwd);
console.log('[DEBUG] specflowDir:', specflowDir);
console.log('[DEBUG] adapter:', adapter?.name);
```

### 2. 使用 Vitest 单元测试

```bash
# 运行测试
npm test

# 监听模式
npm run test:watch

# 覆盖率报告
npm run test:coverage
```

### 3. 测试特定功能

```bash
# 只测试 init 命令
node dist/index.js init --ai iflow --cwd C:\test

# 只测试 new 命令
node dist/index.js new "测试任务" --cwd C:\test
```

### 4. 验证文件生成

```bash
# 检查生成的文件结构
dir /s /b specflow
dir /s /b .iflow

# 查看文件内容
type specflow\AGENTS.md
type .iflow\commands\flow.1-spec.toml
```

---

## 代码引用

- `bin/specflow.js:2` - CLI 入口点，调用编译后的 index.js
- `src/index.ts:10-14` - init 命令定义
- `src/index.ts:16-17` - new 命令定义
- `src/commands/init.ts:13-14` - 使用 `process.cwd()` 作为工作目录
- `src/commands/init.ts:17-21` - 检查目录是否存在
- `src/commands/init.ts:23-28` - 获取适配器
- `src/commands/init.ts:33-52` - 复制模板文件
- `src/commands/new.ts:13-14` - 检查 specflow 目录是否存在
- `src/commands/new.ts:16-19` - 生成任务目录名
- `src/commands/new.ts:21-26` - 创建任务目录结构
- `src/adapters/index.ts:7-12` - 适配器注册表
- `src/adapters/iflow.ts:7-22` - iflow 适配器实现

---

## 相关文件

- `package.json:8` - scripts 定义，包括 `dev` 和 `build`
- `src/index.ts` - CLI 入口和命令路由
- `src/commands/init.ts` - init 命令实现
- `src/commands/new.ts` - new 命令实现
- `src/adapters/` - AI 工具适配器
- `src/templates/` - 内置模板文件
- `.iflow/commands/` - iflow 命令定义

---

## 补充说明

### 为什么 npm run dev 会覆盖文件？

`npm run dev` 执行的是 `tsx src/index.ts`，它会：
1. 运行 TypeScript 源码
2. 当你执行 `specflow init` 时，`process.cwd()` 返回项目根目录
3. 在项目根目录创建 `specflow/` 和 `.iflow/commands/`
4. 覆盖已有的配置文件

### 项目本身的 specflow 目录

项目根目录的 `specflow/` 目录是 SpecFlow 工具的**源代码模板**，不是使用 SpecFlow 管理的任务。这个目录包含：
- `AGENTS.md` - 通用规则
- `templates/` - 输出模板
- `init-specflow/` - 用 SpecFlow 管理的初始化任务（元任务）

### 推荐的目录结构

```
spec-flow/                    # SpecFlow CLI 源代码
├── src/
├── dist/
├── specflow/                 # 源代码模板（不要被覆盖）
└── Q&A/

test-specflow/                # 测试目录（独立）
├── specflow/                 # 测试生成的 specflow 目录
└── .iflow/commands/          # 测试生成的命令
```

---

## 分析时间
2026-01-20 00:00:00